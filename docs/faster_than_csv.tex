% This file was generated by Nim.
% Generated: 2020-09-09 04:02:04 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{faster_than_csv }
\author{}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

import parsecsv, json, tables, streams, strutils, os, osproc, xmltree, punycode, httpclient, experimental/diff, nimpy

const html\_table\_header = """<!DOCTYPE html> <html style="background-color:lightcyan">

\begin{description}\item[<head>] <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="\href{https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.0/css/bulma.min.css"}{https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.0/css/bulma.min.css"}>
\end{description}
</head>

\begin{description}\item[<body><br><br>] \begin{description}\item[<div class="container is-fluid">] <table class="table is-bordered is-striped is-hoverable is-fullwidth">"""
\end{description}

\end{description}
\begin{description}\item[proc csv2list*(csv\_file\_path: string, has\_header: bool = true, separator: char = ',',] quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false): seq\symbol{91}string\symbol{93} \symbol{123}.exportpy.\symbol{125} = \#\# Stream Read CSV to a list of strings. let parser = create(CsvParser, sizeOf CsvParser) parser\symbol{91}\symbol{93}.open(csv\_file\_path, separator, quote, skipInitialSpace=skipInitialSpace)\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow()\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] result.add parser\symbol{91}\symbol{93}.rowEntry(column)
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\item[else:] \begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] result.add \$value
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\end{description}
parser\symbol{91}\symbol{93}.close() dealloc parser


\end{description}
\begin{description}\item[proc csv2dict*(csv\_file\_path: string, has\_header: bool = true, separator: char = ',',] quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false): seq\symbol{91}Table\symbol{91}string, string\symbol{93}\symbol{93} \symbol{123}.exportpy.\symbol{125} = \#\# Stream Read CSV to a list of dictionaries. This is very similar to \texttt{pandas.read\_csv(filename)}. let parser = create(CsvParser, sizeOf CsvParser) parser\symbol{91}\symbol{93}.open(csv\_file\_path, separator, quote, skipInitialSpace=skipInitialSpace)\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow()\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] result.add \symbol{123}\$column: parser\symbol{91}\symbol{93}.rowEntry(column)\symbol{125}.toTable
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\item[else:] let counter = create(int, sizeOf int)\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] result.add \symbol{123}\$counter\symbol{91}\symbol{93}: \$value\symbol{125}.toTable
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows() inc counter\symbol{91}\symbol{93}


\end{description}
dealloc counter


\end{description}
parser\symbol{91}\symbol{93}.close() dealloc parser


\end{description}
\begin{description}\item[proc read\_clipboard*(has\_header: bool = true, separator: char = ',',] quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false): seq\symbol{91}Table\symbol{91}string, string\symbol{93}\symbol{93} \symbol{123}.exportpy.\symbol{125} = \#\# Stream Read CSV to a list of dictionaries. This is very similar to \texttt{pandas.read\_clipboard()}. let output = create(string, sizeOf string) let exitCode = create(int, sizeOf int)\begin{description}\item[(output\symbol{91}\symbol{93}, exitCode\symbol{91}\symbol{93}) = execCmdEx(] when defined(linux):   "xclip -out" elif defined(macos):   "pbpaste" elif defined(windows): "Get-Clipboard" else: "")
\item[if likely(exitCode\symbol{91}\symbol{93} == 0):] let parser = create(CsvParser, sizeOf CsvParser) parser\symbol{91}\symbol{93}.open(newStringStream(output\symbol{91}\symbol{93}), "read\_clipboard", separator, quote, skipInitialSpace=skipInitialSpace)\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow()\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] result.add \symbol{123}\$column: parser\symbol{91}\symbol{93}.rowEntry(column)\symbol{125}.toTable
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\item[else:] let counter = create(int, sizeOf int)\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] result.add \symbol{123}\$counter\symbol{91}\symbol{93}: \$value\symbol{125}.toTable
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows() inc counter\symbol{91}\symbol{93}


\end{description}
dealloc counter


\end{description}
parser\symbol{91}\symbol{93}.close() dealloc parser


\end{description}
dealloc output dealloc exitCode


\end{description}
\begin{description}\item[proc url2csv*(url: string, has\_header: bool = true, separator: char = ',',] quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false, agent: string = defUserAgent; maxRedirects: int = 5; timeout: int = -1): seq\symbol{91}Table\symbol{91}string, string\symbol{93}\symbol{93} \symbol{123}.exportpy.\symbol{125} = \#\# Stream Read URL to CSV to a list of dictionaries. This is very similar to \texttt{pandas.read\_csv(url)}. doAssert url.startsWith"http", "URL must be a valid, non empty string, HTTP URL Link" if unlikely(verbose): echo url let csv\_content = create(string, sizeOf string) csv\_content\symbol{91}\symbol{93} = newHttpClient(userAgent = agent, maxRedirects = maxRedirects, timeout = timeout).getContent(url)  \# opciones\begin{description}\item[if likely(csv\_content\symbol{91}\symbol{93}.len > 0):] let parser = create(CsvParser, sizeOf CsvParser) parser\symbol{91}\symbol{93}.open(newStringStream(csv\_content\symbol{91}\symbol{93}), "url2csv", separator, quote, skipInitialSpace=skipInitialSpace)\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow()\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] result.add \symbol{123}\$column: parser\symbol{91}\symbol{93}.rowEntry(column)\symbol{125}.toTable
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\item[else:] let counter = create(int, sizeOf int)\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] result.add \symbol{123}\$counter\symbol{91}\symbol{93}: \$value\symbol{125}.toTable
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows() inc counter\symbol{91}\symbol{93}


\end{description}
dealloc counter


\end{description}
parser\symbol{91}\symbol{93}.close() dealloc parser


\end{description}
dealloc csv\_content


\end{description}
\begin{description}\item[proc csv2json*(csv\_file\_path: string, has\_header: bool = true,] separator: char = ',', quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false, indentation: Natural = 0): seq\symbol{91}string\symbol{93} \symbol{123}.exportpy.\symbol{125} = \#\# Stream Read CSV to JSON, Pretty-printed or Minified. let parser = create(CsvParser, sizeOf CsvParser) let temp = create(string, sizeOf string) parser\symbol{91}\symbol{93}.open(csv\_file\_path, separator, quote, skipInitialSpace=skipInitialSpace)\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow()\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[if unlikely(indentation != 0):] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] result.add json.pretty(\%*\symbol{123}\$column: parser\symbol{91}\symbol{93}.rowEntry(column)\symbol{125}, indentation)
\end{description}

\item[else:] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] temp\symbol{91}\symbol{93} = "" temp\symbol{91}\symbol{93}.toUgly \%*\symbol{123}\$column: parser\symbol{91}\symbol{93}.rowEntry(column)\symbol{125} result.add temp\symbol{91}\symbol{93}
\end{description}

\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\item[else:] let counter = create(int, sizeOf int)\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[if unlikely(indentation != 0):] \begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] result.add json.pretty(\%*\symbol{123}\$counter\symbol{91}\symbol{93}: \$value\symbol{125}, indentation)
\end{description}

\item[else:] let temp = create(string, sizeOf string)\begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] temp\symbol{91}\symbol{93} = "" temp\symbol{91}\symbol{93}.toUgly \%*\symbol{123}\$counter\symbol{91}\symbol{93}: \$value\symbol{125} result.add temp\symbol{91}\symbol{93}
\end{description}

\end{description}
inc counter\symbol{91}\symbol{93} if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}
dealloc counter


\end{description}
parser\symbol{91}\symbol{93}.close() dealloc temp dealloc parser


\end{description}
\begin{description}\item[proc csv2ndjson*(csv\_file\_path, ndjson\_file\_path: string, has\_header: bool = true, separator: char = ',',] quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false) \symbol{123}.discardable, exportpy.\symbol{125} = \#\# Stream Read CSV to NDJSON \href{https://github.com/ndjson/ndjson-spec}{https://github.com/ndjson/ndjson-spec} let parser = create(CsvParser, sizeOf CsvParser) let ndjson = create(string, sizeOf string) let temp = create(string, sizeOf string) parser\symbol{91}\symbol{93}.open(csv\_file\_path, separator, quote, skipInitialSpace=skipInitialSpace)\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow()\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] temp\symbol{91}\symbol{93} = "" temp\symbol{91}\symbol{93}.toUgly \%*\symbol{123}\$column: parser\symbol{91}\symbol{93}.rowEntry(column)\symbol{125} ndjson\symbol{91}\symbol{93}.add temp\symbol{91}\symbol{93} \& "n"
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\item[else:] let counter = create(int, sizeOf int)\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] temp\symbol{91}\symbol{93} = "" temp\symbol{91}\symbol{93}.toUgly \%*\symbol{123}\$counter\symbol{91}\symbol{93}: \$value\symbol{125} ndjson\symbol{91}\symbol{93}.add temp\symbol{91}\symbol{93} \& "n"
\end{description}
inc counter\symbol{91}\symbol{93} if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}
dealloc counter


\end{description}
writeFile(ndjson\_file\_path, ndjson\symbol{91}\symbol{93}) parser\symbol{91}\symbol{93}.close() dealloc temp dealloc ndjson dealloc parser


\end{description}
\begin{description}\item[proc csv2htmltable*(csv\_file\_path, html\_file\_path: string = "",] has\_header: bool = true, separator: char = ',', quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false, header\_html: string = html\_table\_header): string \symbol{123}.exportpy.\symbol{125} =
\item[] \rsthB{Stream Read CSV to HTML Table file and string.}\label{stream-read-csv-to-html-table-file-and-stringdot}
let parser = create(CsvParser, sizeOf CsvParser) let html\_content = create(string, sizeOf string) parser\symbol{91}\symbol{93}.open(csv\_file\_path, separator, quote, skipInitialSpace=skipInitialSpace) html\_content\symbol{91}\symbol{93}.add header\_html

\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow() html\_content\symbol{91}\symbol{93}.add "<thead class='thead'><tr>"\begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] html\_content\symbol{91}\symbol{93}.add "<th class='has-background-grey-light'>" \& \$column \& "</th>"
\end{description}
html\_content\symbol{91}\symbol{93}.add "</tr>n</thead><tfoot class='tfoot has-text-primary'><tr>"

\begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] html\_content\symbol{91}\symbol{93}.add "<th class='has-background-grey-light'>" \& \$column \& "</th>"
\end{description}
html\_content\symbol{91}\symbol{93}.add "</tr>n</tfoot><tbody class='tbody'>"

\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] html\_content\symbol{91}\symbol{93}.add "<tr>"\begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] html\_content\symbol{91}\symbol{93}.add "<td>" \& parser\symbol{91}\symbol{93}.rowEntry(column) \& "</td>"
\end{description}
html\_content\symbol{91}\symbol{93}.add "</tr>n" if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}
html\_content\symbol{91}\symbol{93}.add "</tbody>n"


\item[else:] \begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] html\_content\symbol{91}\symbol{93}.add "<tbody>"\begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] html\_content\symbol{91}\symbol{93}.add "<td>" \& \$value \& "</td>"
\end{description}
html\_content\symbol{91}\symbol{93}.add "</tbody>n" if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\end{description}
html\_content\symbol{91}\symbol{93}.add "</table></div></body></html>n" parser\symbol{91}\symbol{93}.close()

\begin{description}\item[if html\_file\_path.len > 0:] writeFile(html\_file\_path , html\_content\symbol{91}\symbol{93})
\end{description}
result = html\_content\symbol{91}\symbol{93} dealloc html\_content dealloc parser


\end{description}
\begin{description}\item[proc csv2xml*(csv\_file\_path: string, has\_header: bool = true,] separator: char = ',', quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false, header\_xml: string = xmlHeader): string \symbol{123}.exportpy.\symbol{125} = \#\# Stream Read CSV to XML. let parser = create(CsvParser, sizeOf CsvParser) let temp = create(seq\symbol{91}XmlNode\symbol{93}, sizeOf seq\symbol{91}XmlNode\symbol{93}) let e = create(XmlNode, sizeOf XmlNode) parser\symbol{91}\symbol{93}.open(csv\_file\_path, separator, quote, skipInitialSpace=skipInitialSpace)\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow()\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] e\symbol{91}\symbol{93} = newElement(\$column) e\symbol{91}\symbol{93}.add newText(parser\symbol{91}\symbol{93}.rowEntry(column)) temp\symbol{91}\symbol{93}.add e\symbol{91}\symbol{93}
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\item[else:] let counter = create(int, sizeOf int)\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] e\symbol{91}\symbol{93} = newElement(\$counter\symbol{91}\symbol{93}) e\symbol{91}\symbol{93}.add newText(parser\symbol{91}\symbol{93}.rowEntry(column)) temp\symbol{91}\symbol{93}.add e\symbol{91}\symbol{93}
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}
dealloc counter


\end{description}
parser\symbol{91}\symbol{93}.close() result = header\_xml \& \$newXmlTree("csv", temp\symbol{91}\symbol{93}) dealloc parser dealloc temp dealloc e


\end{description}
\begin{description}\item[proc csv\_punycode2dict*(csv\_file\_path: string, has\_header: bool = true, separator: char = ',',] quote: char = '"', skipInitialSpace: bool = false, verbose: bool = false): seq\symbol{91}Table\symbol{91}string, string\symbol{93}\symbol{93} \symbol{123}.exportpy.\symbol{125} = \#\# Stream read PunyCode encoded CSV to Dict (Punycode encodes Unicode as ASCII). \href{http://wikipedia.org/wiki/Punycode}{http://wikipedia.org/wiki/Punycode} let parser = create(CsvParser, sizeOf CsvParser) parser\symbol{91}\symbol{93}.open(csv\_file\_path, separator, quote, skipInitialSpace=skipInitialSpace)\begin{description}\item[if has\_header:] parser\symbol{91}\symbol{93}.readHeaderRow()\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for column in parser\symbol{91}\symbol{93}.headers.items:] result.add \symbol{123}punycode.decode(\$column): punycode.decode(parser\symbol{91}\symbol{93}.rowEntry(column))\symbol{125}.toTable
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows()


\end{description}

\item[else:] let counter = create(int, sizeOf int)\begin{description}\item[while parser\symbol{91}\symbol{93}.readRow():] \begin{description}\item[for value in parser\symbol{91}\symbol{93}.row.items:] result.add \symbol{123}\$counter\symbol{91}\symbol{93}: punycode.decode(\$value)\symbol{125}.toTable
\end{description}
if unlikely(verbose): echo parser\symbol{91}\symbol{93}.processedRows() inc counter\symbol{91}\symbol{93}


\end{description}
dealloc counter


\end{description}
parser\symbol{91}\symbol{93}.close() dealloc parser


\end{description}
\begin{description}\item[proc csv2tsv*(csv\_file\_path: string, reversed: bool = false): string \symbol{123}.exportpy.\symbol{125} =] \rsthB{Stream Read CSV to TSV, simple replace of "," to "t".}\label{stream-read-csv-to-tsv-simple-replace-of-to-t-dot}
\begin{description}\item[if unlikely(reversed):] \begin{description}\item[for line in csv\_file\_path.lines:] result.add line.replace(',', 't')
\end{description}

\item[else:] \begin{description}\item[for line in csv\_file\_path.lines:] result.add line.replace('t', ',')
\end{description}

\end{description}

\end{description}
\begin{description}\item[proc csv2custom*(csv\_file\_path: string, separator: string, reversed: bool = false): string \symbol{123}.exportpy.\symbol{125} =] \rsthB{Stream Read CSV to TSV, simple replace of "," to "t".}\label{stream-read-csv-to-tsv-simple-replace-of-to-t-dot}
\begin{description}\item[if unlikely(reversed):] \begin{description}\item[for line in csv\_file\_path.lines:] result.add line.replace(separator, ",")
\end{description}

\item[else:] \begin{description}\item[for line in csv\_file\_path.lines:] result.add line.replace(",", separator)
\end{description}

\end{description}

\end{description}
\begin{description}\item[proc diff\_csvs*(csv\_file\_path0, csv\_file\_path1: string): seq\symbol{91}Item\symbol{93} \symbol{123}.exportpy.\symbol{125} =] \rsthB{Diff 2 CSV files.}\label{diff-2-csv-filesdot}
doAssert existsFile(csv\_file\_path0), "File not found: " \& csv\_file\_path0 doAssert existsFile(csv\_file\_path1), "File not found: " \& csv\_file\_path1 diffText(readFile(csv\_file\_path0), readFile(csv\_file\_path1))


\end{description}



\end{document}
